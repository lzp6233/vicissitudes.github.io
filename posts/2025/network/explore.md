# 计算机网络之 探赜索隐

## 传输层

传输层协议为运行在不同的Host上的进程提供了一种**逻辑通信机制**（端到端通信）

+ 端系统运行传输层协议
  + 发送方：将应用递交的消息分成一个或多个segment，并向下传递给网络层
  + 接收方：将接收到的segment组装成消息，并向上交给应用层
+ 分类
  + tcp
    + 拥塞控制
    + 流量控制
    + 连接建立
  + udp
    + Best-effort
+ 网络层：提供主机之间的逻辑通信机制
+ 传输层：提供应用进程之间的逻辑通信机制
  + 位于网络层之上
  + 依赖于网络层服务
  + 对网络层服务进行（可能的）增强

### 多路复用与多路分用

为什么需要多路复用/分用？

![image-20251201193530428](explore.assets/image-20251201193530428.png)

+ 接收端进行多路分用
  + 传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程
+ 发送端进行多路复用
  + 从多个Socket接收数据，为每个数据块封装头部信息，生成Segment，交给网络层

#### 多路分用

+ 主机接收IP数据报
  + 每个数据报携带源IP，目的IP
  + 每个数据报携带一个Segment
  + 源端口，目的端口号
+ 收到segment后，提取IP和port，将Segment导入对应的Socket
  + TCP做更多处理
  + 网络层对端口号透明

+ UDP的多路分用
  + 利用端口号创建Socket
  + 用二元组标识（目的IP，目的端口号）

![image-20251201195856939](explore.assets/image-20251201195856939.png)

+ TCP的多路分用使用四元组标识
  + 源IP
  + 源端口号
  + 目的IP
  + 目的端口号 
  + 服务器可能同时支持多个TCP socket
  + 可以使用面向线程的TCP

![image-20251201195526885](explore.assets/image-20251201195526885.png)

![image-20251201195741863](explore.assets/image-20251201195741863.png)

### UDP协议

+ 基于Internet IP协议
  + 复用/分用
  + 增加简单的错误校验(端到端检测)
+ Best-effort服务
  + 可能丢失
  + 非按序到达
+ 无连接
  + 发送方与接收方不需要握手
  + 每个UDP段段处理相独立
+ UDP为什么存在？
  + 无需建立连接（减小延迟）
  + 实现简单
  + 头部开销小
  + 没有拥塞控制，应用可以更好的控制发送时间和速率
+ 常用于流媒体应用，DNS，SNMP
+ 在UDP上实现可靠数据传输
  + 在应用层实现可靠性，错误恢复机制

<img src="posts/2025/network/explore.assets/image-20251203183557814.png" alt="image-20251203183557814" style="zoom:50%;" />

### 可靠数据传输原理（RDT）

+ 什么是可靠？

  + 不错，不乱，不丢

  <img src="posts/2025/network/explore.assets/image-20251203184650173.png" alt="image-20251203184650173" style="zoom:50%;" />
  + **key：应用接口的箭头为单向，而数据传输为双向箭头**

+ 利用FSM刻画传输协议

  ![image-20251203185156263](explore.assets/image-20251203185156263.png)

#### Rdt1.0

+ 底层信道完全可靠

  + 不发生错误
  + 不会丢弃分组

+ 发送方和接收方的FSM独立

+ 由于是可靠信道，不需要控制交换

  <img src="posts/2025/network/explore.assets/image-20251203185504218.png" alt="image-20251203185504218" style="zoom:80%;" />

#### Rdt2.0

+ 只可能产生位错误的信道
  + 利用校验和来检测位错误
+ 分组不丢失，按序到达

+ 如何从错误恢复？
  + ACK机制：接收方显式告诉发送方分组被接受
  + NAK：分组有误
  + 发送方收到NAK后，重传分组
+ 基于重传机制的rdt协议称为ARQ协议（automatic repeat request)
+ 引入的新机制
  + 差错检测
  + ACK控制
  + 错误重传

![image-20251205175720257](explore.assets/image-20251205175720257.png)

#### Rdt2.1

+ rdt2.0的缺陷
  + ACK/NAK发生错误无法处理
    + 增加校验和，检测错误并纠正（难度大）
    + 发送方收到被破坏的ACK/NAK时不知道发生了什么，添加额外控制消息（不能根本解决问题）
    + 发送方重传ACK，产生重复分组？
  + 如何解决？
    + **序列号（seq number）**
    + 接收方摒弃重复分组

![image-20251209160201997](explore.assets/image-20251209160201997.png)

![image-20251209160317320](explore.assets/image-20251209160317320.png)

#### Rdt2.2:无NAK消息协议

- 与 **rdt 2.1** 功能相同，但是只使用 **ACK**

- 如何实现？
  - 接收方通过 **ACK** 告知最后一个被正确接收的分组
  - 在 **ACK** 消息中显式地加入被确认分组的序列号

- 发送方收到重复 **ACK** 之后，采取与收到 **NAK** 消息相同的动作
  - 重传当前分组

![image-20251209161424649](explore.assets/image-20251209161424649.png)

#### Rdt3.0

+ 如果信道既可能发生错误，也可能丢失分组，怎么办？
  + 发送方等待“合理”的时间
    + 如果没有ack，重传
    + 如果只是延迟，而不是丢失，可能会产生重复问题
      + 使用序列号
    + 接收方显示告诉接受的分组
    + 定时器

发送方：

![image-20251209162351564](explore.assets/image-20251209162351564.png)

接收方：

典型场景：

![image-20251209162712661](explore.assets/image-20251209162712661.png)

![image-20251209162812418](explore.assets/image-20251209162812418.png)

> 性能比较差：停等操作
>
> + 示例：1Gbps链路，15ms端到端传播延迟，1KB分组
>
> $$
> T_{\text{transmit}} = \frac{L \text{ (packet length in bits)}}{R \text{ (transmission rate, bps)}} = \frac{8\,\text{kb/pkt}}{10^9\,\text{b/sec}} = 8\,\mu\text{sec}
> $$
>
> - **发送方利用率**：发送方发送时间百分比
>
> $$
> U_{\text{sender}} = \frac{L / R}{\text{RTT} + L / R} = \frac{0.008}{30.008} = 0.00027
> $$
>
> - 在1Gbps链路上每30毫秒才发送一个分组 → **33KB/sec**
> - 网络协议限制了物理资源的利用

### 滑动窗口协议与流水线机制

流水线机制：提高资源利用率

+ 更大的序列号范围
+ 更大的缓存分组

滑动窗口协议: Sliding-window protocol

+ 窗口
  + 允许使用的序列号范围
  + 窗口尺寸为 **N**: 最多有 **N** 个等待确认的消息

+ 滑动窗口
  + 随着协议的运行，窗口在序列号空间内向前滑动

+ 滑动窗口协议: GBN, SR

#### GBN（go back N）

+ 分组头部k-bit序列号
+ 窗口尺寸N，最多N个分组未确认 

![image-20251209170954123](explore.assets/image-20251209170954123.png)

+ ACK(n):确认到序列号n的分组都被正确接收（包含n）
+ 为空中的分组设置timer
+ 超时：Timeout(n):重传序列号大于等于n，还未收到ACK的所有分组

发送方FSM：

![image-20251209171352783](explore.assets/image-20251209171352783.png)

接收方：
![image-20251209171555375](explore.assets/image-20251209171555375.png)

ACK机制: 发送拥有最高序列号的、已被正确接收的分组的ACK

- 可能产生重复ACK
- 只需要记住唯一的 `expectedseqnum`

乱序到达的分组:

- 直接丢弃 → 接收方没有缓存
- 重新确认序列号最大的、按序到达的分组

> - 数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为 $0 \sim 7$ 的帧。当计时器超时时，若发送方只收到 $0$、$2$、$3$ 号帧的确认，则发送方需要重发的帧数是多少？分别是那几个帧？
>
> - 解：根据 GBN 协议工作原理，GBN 协议的确认是累积确认，所以此时发送端需要重发的帧数是 **4** 个，依次分别是 **4、5、6、7** 号帧。
